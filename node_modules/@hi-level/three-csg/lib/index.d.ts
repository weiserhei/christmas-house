import { Vector3, Mesh, Matrix4 } from 'three';
/**
 * Holds a binary space partition tree representing a 3D solid. Two solids can
 * be combined using the `union()`, `subtract()`, and `intersect()` methods.
 */
export declare class CSG {
    static fromPolygons(polygons: Polygon[]): CSG;
    static fromGeometry(geom: any): CSG;
    static fromMesh(mesh: Mesh): CSG;
    static toMesh(csg: CSG, toMatrix: Matrix4): Mesh;
    static iEval(tokens: Mesh, index?: number): void;
    static eval(tokens: Mesh, doRemove: boolean): Mesh;
    private static _tmpm3;
    private static doRemove;
    private static currentOp;
    private static currentPrim;
    private static nextPrim;
    private static sourceMesh;
    private polygons;
    constructor();
    clone(): CSG;
    toPolygons(): Polygon[];
    union(csg: CSG): CSG;
    subtract(csg: CSG): CSG;
    intersect(csg: CSG): CSG;
    inverse(): CSG;
}
/**
 * Represents a 3D vector.
 */
declare class Vector extends Vector3 {
    constructor(x: number, y: number, z: number);
    clone(): any;
    negated(): Vector;
    plus(a: Vector): Vector;
    minus(a: Vector): Vector;
    times(a: number): Vector;
    dividedBy(a: number): Vector;
    lerp(a: Vector, t: number): any;
    unit(): Vector;
    cross(a: Vector): any;
}
interface IVector {
    x: number;
    y: number;
    z: number;
}
/**
 * Represents a vertex of a polygon. Use your own vertex class instead of this
 * one to provide additional features like texture coordinates and vertex
 * colors. Custom vertex classes need to provide a `pos` property and `clone()`,
 * `flip()`, and `interpolate()` methods that behave analogous to the ones
 * defined by `CSG.Vertex`. This class provides `normal` so convenience
 * functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`
 * is not used anywhere else.
 */
declare class Vertex {
    pos: Vector;
    normal: Vector;
    uv: Vector;
    constructor(pos: IVector, normal: IVector, uv?: IVector);
    clone(): Vertex;
    flip(): void;
    interpolate(other: Vertex, t: number): Vertex;
}
/**
 * Represents a plane in 3D space.
 */
declare class Plane {
    static fromPoints(a: Vector, b: Vector, c: Vector): Plane;
    private static EPSILON;
    normal: Vector;
    w: number;
    constructor(normal: Vector, w: number);
    clone(): Plane;
    flip(): void;
    splitPolygon(polygon: Polygon, coplanarFront: Polygon[], coplanarBack: Polygon[], front: Polygon[], back: Polygon[]): void;
}
/**
 * Represents a convex polygon. The vertices used to initialize a polygon must
 * be coplanar and form a convex loop. They do not have to be `Vertex`
 * instances but they must behave similarly (duck typing can be used for
 * customization).
 *
 * Each convex polygon has a `shared` property, which is shared between all
 * polygons that are clones of each other or were split from the same polygon.
 * This can be used to define per-polygon properties (such as surface color).
 */
declare class Polygon {
    plane: Plane;
    vertices: Vertex[];
    shared: any;
    constructor(vertices: Vertex[], shared?: any);
    clone(): Polygon;
    flip(): void;
}
export {};
